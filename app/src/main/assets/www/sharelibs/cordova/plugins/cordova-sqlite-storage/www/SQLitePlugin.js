cordova.define("cordova-sqlite-storage.SQLitePlugin",function(t,e,n){(function(){var t,e,n,o,a,s,i,r,c,d,l,u;l=this,n=/^\s*(?:drop|delete|insert|update|create)\s/i,t="INIT",e="OPEN",u={},c=function(t,e){var n;return n=t,e||(e=0),n||(n=new Error("a plugin had an error but provided no response"),n.code=e),"string"==typeof n&&(n=new Error(t),n.code=e),!n.code&&n.message&&(n.code=e),n.code||n.message||(n=new Error("an unknown error was returned: "+JSON.stringify(n)),n.code=e),n},d=window.setImmediate||function(t){window.setTimeout(t,0)},i=function(t){return function(){var e,n,o;if(o=arguments.length){for(e=[],n=-1;++n<o;)e[n]=arguments[n];return t.call(this,e)}return t.call(this,[])}},a=function(t,e,n){var o;if(!t||!t.name)throw c("Cannot create a SQLitePlugin db instance without a db name");if(o=t.name,"string"!=typeof o)throw c("sqlite plugin database name must be a string");this.openargs=t,this.dbname=o,this.openSuccess=e,this.openError=n,this.openSuccess||(this.openSuccess=function(){console.log("DB opened: "+o)}),this.openError||(this.openError=function(t){console.log(t.message)}),this.open(this.openSuccess,this.openError)},a.prototype.databaseFeatures={isSQLitePluginDatabase:!0},a.prototype.openDBs={},a.prototype.addTransaction=function(e){u[this.dbname]||(u[this.dbname]={queue:[],inProgress:!1}),u[this.dbname].queue.push(e),this.dbname in this.openDBs&&this.openDBs[this.dbname]!==t?this.startNextTransaction():this.dbname in this.openDBs?console.log("new transaction is waiting for open operation"):console.log("database is closed, new transaction is [stuck] waiting until db is opened again!")},a.prototype.transaction=function(t,e,n){return this.openDBs[this.dbname]?void this.addTransaction(new s(this,t,e,n,(!0),(!1))):void e(c("database not open"))},a.prototype.readTransaction=function(t,e,n){return this.openDBs[this.dbname]?void this.addTransaction(new s(this,t,e,n,(!1),(!0))):void e(c("database not open"))},a.prototype.startNextTransaction=function(){var t;t=this,d(function(n){return function(){var o;return n.dbname in n.openDBs&&n.openDBs[n.dbname]===e?(o=u[t.dbname])?void(o.queue.length>0&&!o.inProgress&&(o.inProgress=!0,o.queue.shift().start())):void console.log("cannot start next transaction: database connection is lost"):void console.log("cannot start next transaction: database not open")}}(this))},a.prototype.abortAllPendingTransactions=function(){var t,e,n,o,a;if(a=u[this.dbname],a&&a.queue.length>0){for(n=a.queue,t=0,e=n.length;t<e;t++)o=n[t],o.abortFromQ(c("Invalid database handle"));a.queue=[],a.inProgress=!1}},a.prototype.open=function(n,o){var a,s;this.dbname in this.openDBs?(console.log("database already open: "+this.dbname),d(function(t){return function(){n(t)}}(this))):(console.log("OPEN database: "+this.dbname),s=function(t){return function(){var o;t.openDBs[t.dbname]||console.log("database was closed during open operation"),t.dbname in t.openDBs&&(t.openDBs[t.dbname]=e),n&&n(t),o=u[t.dbname],o&&o.queue.length>0&&!o.inProgress&&t.startNextTransaction()}}(this),a=function(t){return function(){console.log("OPEN database: "+t.dbname+" failed, aborting any pending transactions"),o&&o(c("Could not open database")),delete t.openDBs[t.dbname],t.abortAllPendingTransactions()}}(this),this.openDBs[this.dbname]=t,cordova.exec(s,a,"SQLitePlugin","open",[this.openargs]))},a.prototype.close=function(t,e){if(this.dbname in this.openDBs){if(u[this.dbname]&&u[this.dbname].inProgress)return console.log("cannot close: transaction is in progress"),void e(c("database cannot be closed while a transaction is in progress"));console.log("CLOSE database: "+this.dbname),delete this.openDBs[this.dbname],u[this.dbname]?console.log("closing db with transaction queue length: "+u[this.dbname].queue.length):console.log("closing db with no transaction lock state"),cordova.exec(t,e,"SQLitePlugin","close",[{path:this.dbname}])}else console.log("cannot close: database is not open"),e&&d(function(){return e()})},a.prototype.executeSql=function(t,e,n,o){var a,i,r;r=function(t,e){if(n)return n(e)},a=function(t,e){if(o)return o(e)},i=function(n){n.addStatement(t,e,r,a)},this.addTransaction(new s(this,i,null,null,(!1),(!1)))},s=function(t,e,n,o,a,s){if("function"!=typeof e)throw c("transaction expected a function");this.db=t,this.fn=e,this.error=n,this.success=o,this.txlock=a,this.readOnly=s,this.executes=[],a&&this.addStatement("BEGIN",[],null,function(t,e){throw c("unable to begin transaction: "+e.message,e.code)})},s.prototype.start=function(){var t,e;try{this.fn(this),this.run()}catch(e){if(t=e,u[this.db.dbname].inProgress=!1,this.db.startNextTransaction(),!this.error)throw t;throw this.error(c(t)),e}},s.prototype.executeSql=function(t,e,o,a){if(this.finalized)throw{message:"InvalidStateError: DOM Exception 11: This transaction is already finalized. Transactions are committed after its success or failure handlers are called. If you are using a Promise to handle callbacks, be aware that implementations following the A+ standard adhere to run-to-completion semantics and so Promise resolution occurs on a subsequent tick and therefore after the transaction commits.",code:11};return this.readOnly&&n.test(t)?void this.handleStatementFailure(a,{message:"invalid sql for a read-only transaction"}):void this.addStatement(t,e,o,a)},s.prototype.addStatement=function(t,e,n,o){var a,s,i,r,c;if(i=[],e&&e.constructor===Array)for(a=0,s=e.length;a<s;a++)c=e[a],r=typeof c,i.push(null===c||void 0===c||"number"===r||"string"===r?c:c instanceof Blob?c.valueOf():c.toString());this.executes.push({success:n,error:o,sql:t,params:i})},s.prototype.handleStatementSuccess=function(t,e){var n,o;t&&(o=e.rows||[],n={rows:{item:function(t){return o[t]},length:o.length},rowsAffected:e.rowsAffected||0,insertId:e.insertId||void 0},t(this,n))},s.prototype.handleStatementFailure=function(t,e){if(!t)throw c("a statement with no error handler failed: "+e.message,e.code);if(t(this,e)!==!1)throw c("a statement error callback did not return false: "+e.message,e.code)},s.prototype.run=function(){var t,e,n,o,a,s,i,r,d,l;for(d=null,i=[],t=this.executes,l=t.length,this.executes=[],r=this,e=function(e,n){return function(o){n?r.handleStatementSuccess(t[e].success,o):r.handleStatementFailure(t[e].error,c(o)),0===--l&&(d?r.abort(d):r.executes.length>0?r.run():r.finish())}},n=0,a={};n<t.length;)s=t[n],a[n]={success:e(n,!0),error:e(n,!1)},i.push({qid:1111,sql:s.sql,params:s.params}),n++;o=function(t){var e,o,s,i,r,c,d;for(o=t.length-1,n=e=0,r=o;0<=r?e<=r:e>=r;n=0<=r?++e:--e)i=t[n],d=i.type,c=i.result,s=a[n],s&&s[d]&&s[d](c)},cordova.exec(o,null,"SQLitePlugin","backgroundExecuteSqlBatch",[{dbargs:{dbname:this.db.dbname},executes:i}])},s.prototype.abort=function(t){var e,n,o;this.finalized||(o=this,n=function(e){u[e.db.dbname].inProgress=!1,e.db.startNextTransaction(),e.error&&e.error(t)},e=function(t,e){u[t.db.dbname].inProgress=!1,t.db.startNextTransaction(),t.error&&t.error(c("error while trying to roll back: "+e.message,e.code))},this.finalized=!0,this.txlock?(this.addStatement("ROLLBACK",[],n,e),this.run()):n(o))},s.prototype.finish=function(){var t,e,n;this.finalized||(n=this,e=function(t){u[t.db.dbname].inProgress=!1,t.db.startNextTransaction(),t.success&&t.success()},t=function(t,e){u[t.db.dbname].inProgress=!1,t.db.startNextTransaction(),t.error&&t.error(c("error while trying to commit: "+e.message,e.code))},this.finalized=!0,this.txlock?(this.addStatement("COMMIT",[],e,t),this.run()):e(n))},s.prototype.abortFromQ=function(t){this.error&&this.error(t)},r=["docs","libs","nosync"],o={opendb:i(function(t){var e,n,o,s,i;return t.length<1?null:(o=t[0],i=null,s=null,n=null,o.constructor===String?(i={name:o},t.length>=5&&(s=t[4],t.length>5&&(n=t[5]))):(i=o,t.length>=2&&(s=t[1],t.length>2&&(n=t[2]))),e=i.location?r[i.location]:null,i.dblocation=e||r[0],i.createFromLocation&&1===i.createFromLocation&&(i.createFromResource="1"),i.androidDatabaseImplementation&&2===i.androidDatabaseImplementation&&(i.androidOldDatabaseImplementation=1),i.androidLockWorkaround&&1===i.androidLockWorkaround&&(i.androidBugWorkaround=1),new a(i,s,n))}),deleteDb:function(t,e,n){var o,s;if(o={},t.constructor===String)o.path=t,o.dblocation=r[0];else{if(!t||!t.name)throw new Error("Please specify db name");o.path=t.name,s=t.location?r[t.location]:null,o.dblocation=s||r[0]}return delete a.prototype.openDBs[o.path],cordova.exec(e,n,"SQLitePlugin","delete",[o])}},l.sqlitePlugin={sqliteFeatures:{isSQLitePlugin:!0},openDatabase:o.opendb,deleteDatabase:o.deleteDb}}).call(this)});